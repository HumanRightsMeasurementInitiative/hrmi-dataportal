{
  "ast": null,
  "code": "\"use strict\";\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar _react = require(\"react\");\n\nvar isServer = false;\n\nvar _default = function _default() {\n  var mountedInstances = new Set();\n  var state;\n\n  function emitChange(component) {\n    state = component.props.reduceComponentsToState(_toConsumableArray(mountedInstances), component.props);\n\n    if (component.props.handleStateChange) {\n      component.props.handleStateChange(state);\n    }\n  }\n\n  return /*#__PURE__*/function (_react$Component) {\n    _inherits(_class, _react$Component);\n\n    var _super = _createSuper(_class);\n\n    _createClass(_class, null, [{\n      key: \"rewind\",\n      // Used when server rendering\n      value: function rewind() {\n        var recordedState = state;\n        state = undefined;\n        mountedInstances.clear();\n        return recordedState;\n      }\n    }]);\n\n    function _class(props) {\n      var _this;\n\n      _classCallCheck(this, _class);\n\n      _this = _super.call(this, props);\n\n      if (isServer) {\n        mountedInstances.add(_assertThisInitialized(_this));\n        emitChange(_assertThisInitialized(_this));\n      }\n\n      return _this;\n    }\n\n    _createClass(_class, [{\n      key: \"componentDidMount\",\n      value: function componentDidMount() {\n        mountedInstances.add(this);\n        emitChange(this);\n      }\n    }, {\n      key: \"componentDidUpdate\",\n      value: function componentDidUpdate() {\n        emitChange(this);\n      }\n    }, {\n      key: \"componentWillUnmount\",\n      value: function componentWillUnmount() {\n        mountedInstances.delete(this);\n        emitChange(this);\n      }\n    }, {\n      key: \"render\",\n      value: function render() {\n        return null;\n      }\n    }]);\n\n    return _class;\n  }(_react.Component);\n};\n\nexports.default = _default;",
  "map": {
    "version": 3,
    "sources": ["../../../next-server/lib/side-effect.tsx"],
    "names": [
      "isServer",
      "mountedInstances",
      "state",
      "component",
      "Component",
      "recordedState",
      "constructor",
      "emitChange",
      "componentDidMount",
      "componentDidUpdate",
      "componentWillUnmount",
      "render"
    ],
    "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,IAAA,MAAA,GAAA,OAAA,CAAA,OAAA,CAAA;;AAEA,IAAMA,QAAN,QAAA;;eAae,S,QAAA,GAAM;AACnB,MAAMC,gBAA0B,GAAG,IAAnC,GAAmC,EAAnC;AACA,MAAA,KAAA;;AAEA,WAAA,UAAA,CAAA,SAAA,EAAuE;AACrEC,IAAAA,KAAK,GAAGC,SAAS,CAATA,KAAAA,CAAAA,uBAAAA,oBAAAA,gBAAAA,GAENA,SAAS,CAFXD,KAAQC,CAARD;;AAIA,QAAIC,SAAS,CAATA,KAAAA,CAAJ,iBAAA,EAAuC;AACrCA,MAAAA,SAAS,CAATA,KAAAA,CAAAA,iBAAAA,CAAAA,KAAAA;AAEH;AAED;;AAAA;AAAA;;AAAA;;AAAA;AAAA;AACE;AADF,+BAEkB;AACd,YAAME,aAAa,GAAnB,KAAA;AACAH,QAAAA,KAAK,GAALA,SAAAA;AACAD,QAAAA,gBAAgB,CAAhBA,KAAAA;AACA,eAAA,aAAA;AAGFK;AATF;;AASEA,oBAAW,KAAXA,EAAwB;AAAA;;AAAA;;AACtB,gCAAA,KAAA;;AACA,UAAA,QAAA,EAAc;AACZL,QAAAA,gBAAgB,CAAhBA,GAAAA;AACAM,QAAAA,UAAAA,+BAAAA;AAEH;;AANuB;AAOxBC;;AAhBF;AAAA;AAAA,0CAgBsB;AAClBP,QAAAA,gBAAgB,CAAhBA,GAAAA,CAAAA,IAAAA;AACAM,QAAAA,UAAU,CAAVA,IAAU,CAAVA;AAEFE;AApBF;AAAA;AAAA,2CAoBuB;AACnBF,QAAAA,UAAU,CAAVA,IAAU,CAAVA;AAEFG;AAvBF;AAAA;AAAA,6CAuByB;AACrBT,QAAAA,gBAAgB,CAAhBA,MAAAA,CAAAA,IAAAA;AACAM,QAAAA,UAAU,CAAVA,IAAU,CAAVA;AAGFI;AA5BF;AAAA;AAAA,+BA4BW;AACP,eAAA,IAAA;AA7BJ;AAAA;;AAAA;AAAA,IAAqBP,MAAAA,CAAAA,SAArB",
    "sourcesContent": [
      "import React, { Component } from 'react'\n\nconst isServer = typeof window === 'undefined'\n\ntype State = Array<React.ReactElement<any>> | undefined\n\ntype SideEffectProps = {\n  reduceComponentsToState: <T>(\n    components: Array<React.ReactElement<any>>,\n    props: T\n  ) => State\n  handleStateChange?: (state: State) => void\n  inAmpMode?: boolean\n}\n\nexport default () => {\n  const mountedInstances: Set<any> = new Set()\n  let state: State\n\n  function emitChange(component: React.Component<SideEffectProps>): void {\n    state = component.props.reduceComponentsToState(\n      [...mountedInstances],\n      component.props\n    )\n    if (component.props.handleStateChange) {\n      component.props.handleStateChange(state)\n    }\n  }\n\n  return class extends Component<SideEffectProps> {\n    // Used when server rendering\n    static rewind() {\n      const recordedState = state\n      state = undefined\n      mountedInstances.clear()\n      return recordedState\n    }\n\n    constructor(props: any) {\n      super(props)\n      if (isServer) {\n        mountedInstances.add(this)\n        emitChange(this)\n      }\n    }\n    componentDidMount() {\n      mountedInstances.add(this)\n      emitChange(this)\n    }\n    componentDidUpdate() {\n      emitChange(this)\n    }\n    componentWillUnmount() {\n      mountedInstances.delete(this)\n      emitChange(this)\n    }\n\n    render() {\n      return null\n    }\n  }\n}\n"
    ]
  },
  "metadata": {},
  "sourceType": "script"
}
